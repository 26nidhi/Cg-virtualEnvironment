<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Frozen 3D Environment — Lab3 (Enhanced Actors + Interactions)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #1a2a4e, #2d4a7c);
        }
        #canvas-container { width: 100vw; height: 100vh; position: relative; }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,20,60,0.85);
            color: #a8d8ff;
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 420px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(168,216,255,0.3);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        #info-panel h2 { color: #ffffff; margin-bottom: 12px; font-size: 18px; text-shadow: 0 0 10px rgba(168,216,255,0.5); }
        #info-panel p { margin: 8px 0; line-height: 1.6; }
        .control-key { background: rgba(168,216,255,0.2); padding: 2px 6px; border-radius: 3px; font-weight: bold; color: #ffffff; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #ffffff; font-size: 24px; text-align: center; text-shadow: 0 0 20px rgba(168,216,255,0.8); z-index: 10; }
        .spinner { border: 4px solid rgba(168,216,255,0.3); border-top: 4px solid #a8d8ff; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #legend { margin-top: 10px; font-size: 12px; color: #8ab8e6; }
        #debug { margin-top: 10px; font-size: 11px; color: #6ab8ff; font-family: monospace; }
        .on { color: #0f0; font-weight: bold; }
        .off { color: #f66; font-weight: bold; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="loading">
        <div class="spinner"></div>
        <p>Loading Arendelle...</p>
    </div>

    <div id="info-panel">
        <h2>❄ Frozen 3D Environment — Lab3</h2>
        <p><span class="control-key">Mouse</span> - Rotate & Zoom</p>
        <p><span class="control-key">Space</span> - Toggle Animation</p>
        <p><span class="control-key">A</span> - Toggle Aurora</p>
        <p><span class="control-key">S</span> - Toggle Snow</p>
        <p><span class="control-key">L</span> - Toggle Lights</p>
        <p><span class="control-key">I</span> - Toggle Interactions</p>
        <p><span class="control-key">R</span> - Toggle Reindeers</p>
        <p><span class="control-key">M</span> - Toggle Snowmen</p>
        <p><span class="control-key">D</span> - Toggle All Actors</p>
        <div id="legend">
            Actors: 3 Reindeers with AI behaviors, Snowmen, Lanterns, Ice sculptures, Anna character.
            <strong>NEW:</strong> Reindeers approach Anna, circle her with realistic tree collision avoidance!
        </div>
        <div id="debug">
            <strong>LIVE DEBUG:</strong><br>
            Interactions: <span id="int-status" class="on">ON</span><br>
            <span id="reindeer-status"></span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // GLOBALS
        let scene, camera, renderer;
        let castleGroup, snowParticles, auroraPlane, lake;
        let animationEnabled = true;
        let auroraEnabled = true;
        let snowEnabled = true;
        let lightsEnabled = true;
        let interactionsEnabled = true;
        let time = 0;

        let ambientLight, directionalLight, castleLight1, castleLight2, auroraLight;

        let actorsGroup;
        let reindeers = [];
        let snowmen = [];
        let lanterns = [];
        let characters = [];
        let anna = null;
        let actorsEnabled = true;

        const castleExclusionRadius = 18;

        const ANNA_URL = 'https://upload.wikimedia.org/wikipedia/en/thumb/8/8a/Anna_Frozen.png/120px-Anna_Frozen.png';

        // STATE MACHINE FOR REINDEERS
        const STATE = {
            WANDER: 0,
            APPROACH: 1,
            CIRCLE: 2,
            FOLLOW: 3,
            GREET: 4,
            REST: 5
        };

        const STATE_NAMES = ['WANDER', 'APPROACH', 'CIRCLE', 'FOLLOW', 'GREET', 'REST'];

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a2a4e, 50, 300);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 30, 50);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            setupControls();
            createLighting();
            createTerrain();
            createCastle();
            createTrees();
            createLake();
            createAurora();
            createSnowParticles();
            createActors();
            setupEventListeners();

            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let cameraRotation = { theta: 0, phi: Math.PI / 6 };
            let cameraDistance = 80;

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    cameraRotation.theta -= deltaX * 0.01;
                    cameraRotation.phi -= deltaY * 0.01;
                    cameraRotation.phi = Math.max(0.1, Math.min(Math.PI / 2, cameraRotation.phi));
                    updateCameraPosition();
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
            renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.05;
                cameraDistance = Math.max(30, Math.min(150, cameraDistance));
                updateCameraPosition();
            });

            function updateCameraPosition() {
                camera.position.x = cameraDistance * Math.sin(cameraRotation.phi) * Math.cos(cameraRotation.theta);
                camera.position.y = cameraDistance * Math.cos(cameraRotation.phi);
                camera.position.z = cameraDistance * Math.sin(cameraRotation.phi) * Math.sin(cameraRotation.theta);
                camera.lookAt(0, 15, 0);
            }

            updateCameraPosition();
        }

        function createLighting() {
            ambientLight = new THREE.AmbientLight(0x6699cc, 0.5);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xaaccff, 0.9);
            directionalLight.position.set(50, 80, 30);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            castleLight1 = new THREE.PointLight(0x88ccff, 1.5, 50);
            castleLight1.position.set(0, 25, 0);
            scene.add(castleLight1);

            castleLight2 = new THREE.PointLight(0xaaddff, 1.2, 40);
            castleLight2.position.set(0, 35, 0);
            scene.add(castleLight2);

            auroraLight = new THREE.PointLight(0x00ff88, 0.5, 100);
            auroraLight.position.set(0, 60, -30);
            scene.add(auroraLight);
        }

        function createTerrain() {
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.random() * 3 - 1;
            }
            groundGeometry.attributes.position.needsUpdate = true;
            groundGeometry.computeVertexNormals();

            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                shininess: 60,
                specular: 0x444444,
                flatShading: false
            });

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            for (let i = 0; i < 15; i++) {
                const rockGeometry = new THREE.SphereGeometry(Math.random() * 3 + 1, 8, 8);
                const rockMaterial = new THREE.MeshPhongMaterial({ color: 0xaabbcc, shininess: 10 });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(Math.random() * 100 - 50, -1, Math.random() * 100 - 50);
                rock.scale.y = 0.5;
                rock.receiveShadow = true;
                rock.castShadow = true;
                scene.add(rock);
            }
        }

        function createCastle() {
            castleGroup = new THREE.Group();

            const iceMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaddff,
                transparent: true,
                opacity: 0.85,
                shininess: 100,
                specular: 0xffffff,
                reflectivity: 0.9
            });

            const baseGeometry = new THREE.BoxGeometry(20, 20, 20);
            const base = new THREE.Mesh(baseGeometry, iceMaterial);
            base.position.y = 10;
            base.castShadow = true;
            base.receiveShadow = true;
            castleGroup.add(base);

            const towerPositions = [[-8, 0, -8], [8, 0, -8], [-8, 0, 8], [8, 0, 8]];
            towerPositions.forEach(pos => {
                const towerGeometry = new THREE.CylinderGeometry(3, 4, 30, 8);
                const tower = new THREE.Mesh(towerGeometry, iceMaterial);
                tower.position.set(pos[0], pos[1] + 25, pos[2]);
                tower.castShadow = true;
                tower.receiveShadow = true;
                castleGroup.add(tower);

                const roofGeometry = new THREE.ConeGeometry(4.5, 8, 8);
                const roof = new THREE.Mesh(roofGeometry, iceMaterial);
                roof.position.set(pos[0], pos[1] + 44, pos[2]);
                roof.castShadow = true;
                castleGroup.add(roof);

                const windowGeometry = new THREE.SphereGeometry(0.8, 8, 8);
                const windowMaterial = new THREE.MeshBasicMaterial({ color: 0xffeeaa, transparent: true, opacity: 0.9 });
                const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
                window1.position.set(pos[0], pos[1] + 30, pos[2] > 0 ? pos[2] + 4 : pos[2] - 4);
                castleGroup.add(window1);
            });

            const spireGeometry = new THREE.ConeGeometry(5, 40, 6);
            const spire = new THREE.Mesh(spireGeometry, iceMaterial);
            spire.position.y = 45;
            spire.castShadow = true;
            castleGroup.add(spire);

            for (let i = 0; i < 5; i++) {
                const crystalGeometry = new THREE.OctahedronGeometry(2);
                const crystal = new THREE.Mesh(crystalGeometry, iceMaterial);
                const angle = (i / 5) * Math.PI * 2;
                crystal.position.set(Math.cos(angle) * 8, 22, Math.sin(angle) * 8);
                crystal.rotation.z = Math.random() * Math.PI;
                castleGroup.add(crystal);
            }

            scene.add(castleGroup);
        }

        function createTrees() {
            const treeMaterial = new THREE.MeshPhongMaterial({ color: 0x1a4d2e, shininess: 5 });
            const snowMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 30 });

            // Store tree positions for collision detection
            window.treePositions = [];

            for (let i = 0; i < 30; i++) {
                const treeGroup = new THREE.Group();
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 5, 8);
                const trunk = new THREE.Mesh(trunkGeometry, treeMaterial);
                trunk.position.y = 2.5;
                trunk.castShadow = true;
                treeGroup.add(trunk);

                for (let j = 0; j < 3; j++) {
                    const coneGeometry = new THREE.ConeGeometry(3 - j * 0.5, 5, 8);
                    const cone = new THREE.Mesh(coneGeometry, treeMaterial);
                    cone.position.y = 5 + j * 3;
                    cone.castShadow = true;
                    treeGroup.add(cone);

                    const snowCone = new THREE.Mesh(new THREE.ConeGeometry(3.2 - j * 0.5, 1, 8), snowMaterial);
                    snowCone.position.y = 7.5 + j * 3;
                    treeGroup.add(snowCone);
                }

                let x, z;
                let distToCenter, distToAnna;
                do {
                    x = Math.random() * 120 - 60;
                    z = Math.random() * 120 - 60;
                    // Avoid castle center area AND clear large area around Anna at (0, 0, 35)
                    distToCenter = Math.sqrt(x * x + z * z);
                    distToAnna = Math.sqrt(x * x + (z - 35) * (z - 35));
                } while ((Math.abs(x) < 25 && Math.abs(z) < 25) || distToAnna < 25);

                treeGroup.position.set(x, 0, z);
                treeGroup.scale.setScalar(0.8 + Math.random() * 0.4);
                
                // Store tree position and radius for collision
                window.treePositions.push({
                    x: x,
                    z: z,
                    radius: 3.5 * treeGroup.scale.x // Collision radius based on tree size
                });
                
                scene.add(treeGroup);
            }
        }

        function createLake() {
            const lakeGeometry = new THREE.CircleGeometry(25, 32);
            const lakeMaterial = new THREE.MeshPhongMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.7,
                shininess: 150,
                specular: 0xffffff,
                side: THREE.DoubleSide
            });

            lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
            lake.rotation.x = -Math.PI / 2;
            lake.position.set(35, 0.1, 35);
            lake.receiveShadow = true;
            scene.add(lake);

            for (let i = 0; i < 8; i++) {
                const iceGeometry = new THREE.DodecahedronGeometry(Math.random() * 2 + 1);
                const iceMaterial = new THREE.MeshPhongMaterial({ color: 0xcceeFF, transparent: true, opacity: 0.8, shininess: 100 });
                const iceChunk = new THREE.Mesh(iceGeometry, iceMaterial);
                const angle = (i / 8) * Math.PI * 2;
                const radius = 15 + Math.random() * 8;
                iceChunk.position.set(35 + Math.cos(angle) * radius, 0.5, 35 + Math.sin(angle) * radius);
                iceChunk.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                scene.add(iceChunk);
            }
        }

        function createAurora() {
            const auroraGeometry = new THREE.PlaneGeometry(150, 80, 32, 32);
            const vertices = auroraGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.1) * 3;
            }
            auroraGeometry.attributes.position.needsUpdate = true;

            const auroraMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });

            auroraPlane = new THREE.Mesh(auroraGeometry, auroraMaterial);
            auroraPlane.position.set(0, 60, -50);
            auroraPlane.rotation.x = Math.PI / 6;
            scene.add(auroraPlane);

            const aurora2 = auroraPlane.clone();
            aurora2.material = auroraMaterial.clone();
            aurora2.material.color.setHex(0x4488ff);
            aurora2.position.z = -55;
            aurora2.position.y = 55;
            scene.add(aurora2);
        }

        function createSnowParticles() {
            const particleCount = 5000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                do {
                    x = Math.random() * 200 - 100;
                    y = Math.random() * 100;
                    z = Math.random() * 200 - 100;
                } while (Math.sqrt(x * x + z * z) < castleExclusionRadius && y < 60);

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                velocities.push({
                    x: Math.random() * 0.1 - 0.05,
                    y: -Math.random() * 0.2 - 0.1,
                    z: Math.random() * 0.1 - 0.05
                });
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.velocities = velocities;

            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            snowParticles = new THREE.Points(particles, particleMaterial);
            scene.add(snowParticles);
        }

        function createActors() {
            actorsGroup = new THREE.Group();
            scene.add(actorsGroup);

            const lanternPositions = [
                [-18, 0, -10], [-10, 0, -18], [10, 0, -18], [18, 0, -10],
                [-18, 0, 10],  [-10, 0, 18],  [10, 0, 18],  [18, 0, 10]
            ];
            lanternPositions.forEach(p => {
                lanterns.push(createLantern(new THREE.Vector3(p[0], 0, p[2])));
            });

            snowmen.push(createSnowman(new THREE.Vector3(-15, 0, -15)));
            snowmen.push(createSnowman(new THREE.Vector3(15, 0, -15)));
            snowmen.push(createSnowman(new THREE.Vector3(-15, 0, 15)));
            snowmen.push(createSnowman(new THREE.Vector3(15, 0, 15)));

            // Reindeers starting positions (near the lake area)
            reindeers.push(createReindeer(new THREE.Vector3(50, 0, 40), 0, true));  // Leader
            reindeers.push(createReindeer(new THREE.Vector3(30, 0, 50), 1, false));
            reindeers.push(createReindeer(new THREE.Vector3(45, 0, 30), 2, false));

            // Anna positioned FAR in front of castle in wide open area - clearly visible
            anna = createImageCharacter(ANNA_URL, new THREE.Vector3(0, 0, 35), 11);
            characters.push(anna);

            placeIceSculpturesAroundCastle();

            lanterns.forEach(l => actorsGroup.add(l.group));
            snowmen.forEach(s => actorsGroup.add(s.group));
            reindeers.forEach(r => actorsGroup.add(r.group));
            characters.forEach(c => actorsGroup.add(c.group));

            actorsGroup.visible = actorsEnabled;
        }

        function createLantern(position) {
            const group = new THREE.Group();
            group.position.copy(position);

            const poleGeom = new THREE.CylinderGeometry(0.1, 0.1, 4, 6);
            const poleMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const pole = new THREE.Mesh(poleGeom, poleMat);
            pole.position.y = 2;
            pole.castShadow = true;
            group.add(pole);

            const lampGeom = new THREE.SphereGeometry(0.6, 8, 8);
            const lampMat = new THREE.MeshBasicMaterial({ color: 0xffeaa3 });
            const lamp = new THREE.Mesh(lampGeom, lampMat);
            lamp.position.y = 3.2;
            group.add(lamp);

            const light = new THREE.PointLight(0xffeaa3, 0.8, 12);
            light.position.set(0, 3.2, 0);
            group.add(light);

            return { group, light, lamp, baseIntensity: 0.8, flickerSpeed: 2 + Math.random() * 2 };
        }

        function createSnowman(position) {
            const group = new THREE.Group();
            group.position.copy(position);

            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 40 });
            const coalMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
            const carrotMat = new THREE.MeshPhongMaterial({ color: 0xff7f00 });
            const hatMat = new THREE.MeshPhongMaterial({ color: 0x000000 });

            const bottom = new THREE.Mesh(new THREE.SphereGeometry(3.2, 16, 16), bodyMat);
            bottom.position.y = 3.2;
            bottom.castShadow = true;
            group.add(bottom);

            const mid = new THREE.Mesh(new THREE.SphereGeometry(2.4, 16, 16), bodyMat);
            mid.position.y = 7.0;
            mid.castShadow = true;
            group.add(mid);

            const head = new THREE.Mesh(new THREE.SphereGeometry(1.6, 16, 16), bodyMat);
            head.position.y = 9.8;
            head.castShadow = true;
            group.add(head);

            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), coalMat);
            const eye2 = eye1.clone();
            eye1.position.set(0.5, 10.1, 1.4);
            eye2.position.set(-0.5, 10.1, 1.4);
            group.add(eye1, eye2);

            const nose = new THREE.Mesh(new THREE.ConeGeometry(0.2, 1.4, 8), carrotMat);
            nose.position.set(0, 9.7, 2.0);
            nose.rotation.x = Math.PI / 2;
            group.add(nose);

            const hatBase = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.4, 0.3, 12), hatMat);
            hatBase.position.set(0, 11.5, 0);
            group.add(hatBase);

            const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 0.9, 1.8, 12), hatMat);
            hatTop.position.set(0, 12.5, 0);
            group.add(hatTop);

            for (let i = 0; i < 3; i++) {
                const button = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), coalMat);
                button.position.set(0, 7.5 - i * 0.7, 2.2);
                group.add(button);
            }

            return { group, baseY: group.position.y, bobOffset: Math.random() * Math.PI, bobSpeed: 1 + Math.random() * 1.5 };
        }

        function createReindeer(position, id, isLeader) {
            const group = new THREE.Group();
            group.position.copy(position);

            const bodyMat = new THREE.MeshPhongMaterial({ color: isLeader ? 0xaa6633 : 0x8B4513, shininess: 30 });
            const darkMat = new THREE.MeshPhongMaterial({ color: 0x654321, shininess: 20 });
            const noseMat = new THREE.MeshPhongMaterial({ color: 0xff3333, emissive: 0xff0000, emissiveIntensity: 0.5 });
            const antlerMat = new THREE.MeshPhongMaterial({ color: 0xd2b48c, shininess: 10 });
            const eyeMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const bellyMat = new THREE.MeshPhongMaterial({ color: 0xa0826d, shininess: 25 });

            const body = new THREE.Mesh(new THREE.SphereGeometry(2.5, 16, 16), bodyMat);
            body.scale.set(1.6, 1.3, 1.1);
            body.position.y = 4;
            body.castShadow = true;
            group.add(body);

            const belly = new THREE.Mesh(new THREE.SphereGeometry(2.3, 16, 16), bellyMat);
            belly.scale.set(1.3, 1.1, 0.9);
            belly.position.set(0, 3.8, 0.8);
            group.add(belly);

            const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 1.3, 3.5, 12), bodyMat);
            neck.position.set(0, 6, 2.5);
            neck.rotation.x = -0.4;
            neck.castShadow = true;
            group.add(neck);

            const head = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), bodyMat);
            head.scale.set(1, 1.1, 1.4);
            head.position.set(0, 8.2, 4);
            head.castShadow = true;
            group.add(head);

            const snout = new THREE.Mesh(new THREE.SphereGeometry(0.8, 12, 12), darkMat);
            snout.scale.set(0.8, 0.7, 1.3);
            snout.position.set(0, 7.8, 5.2);
            group.add(snout);

            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), noseMat);
            nose.position.set(0, 7.6, 6.2);
            group.add(nose);

            const noseLight = new THREE.PointLight(0xff0000, 0.8, 8);
            noseLight.position.set(0, 7.6, 6.5);
            group.add(noseLight);

            const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12), eyeMat);
            const eye2 = eye1.clone();
            eye1.position.set(0.6, 8.5, 5);
            eye2.position.set(-0.6, 8.5, 5);
            group.add(eye1, eye2);

            const earGeom = new THREE.ConeGeometry(0.6, 1.8, 8);
            const ear1 = new THREE.Mesh(earGeom, bodyMat);
            const ear2 = ear1.clone();
            ear1.position.set(0.9, 9.5, 3.8);
            ear2.position.set(-0.9, 9.5, 3.8);
            ear1.rotation.z = -0.3;
            ear2.rotation.z = 0.3;
            group.add(ear1, ear2);

            const antlerBase1 = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 2, 8), antlerMat);
            const antlerBase2 = antlerBase1.clone();
            antlerBase1.position.set(0.7, 9.8, 3.5);
            antlerBase2.position.set(-0.7, 9.8, 3.5);
            antlerBase1.rotation.z = -0.4;
            antlerBase2.rotation.z = 0.4;
            group.add(antlerBase1, antlerBase2);

            for (let side = -1; side <= 1; side += 2) {
                const branch1 = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.12, 1.2, 6), antlerMat);
                branch1.position.set(side * 0.8, 10.8, 3.4);
                branch1.rotation.set(0.3, side * 0.5, side * -0.6);
                group.add(branch1);

                const branch2 = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.12, 1, 6), antlerMat);
                branch2.position.set(side * 0.9, 10.3, 3.6);
                branch2.rotation.set(-0.3, side * -0.3, side * -0.5);
                group.add(branch2);
            }

            const legPositions = [
                [1.5, 0, 1.5], [-1.5, 0, 1.5],
                [1.5, 0, -1], [-1.5, 0, -1]
            ];

            const legs = [];
            legPositions.forEach((pos, idx) => {
                const legGroup = new THREE.Group();
                
                const upperLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.35, 2.5, 8), bodyMat);
                upperLeg.position.y = 1.5;
                upperLeg.castShadow = true;
                legGroup.add(upperLeg);

                const lowerLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.25, 1.5, 8), darkMat);
                lowerLeg.position.y = 0.4;
                legGroup.add(lowerLeg);

                const hoof = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.3, 0.6), new THREE.MeshPhongMaterial({ color: 0x2c1810 }));
                hoof.position.y = -0.2;
                legGroup.add(hoof);

                legGroup.position.set(pos[0], pos[1] + 0.5, pos[2]);
                group.add(legGroup);
                legs.push(legGroup);
            });

            const tail = new THREE.Mesh(new THREE.ConeGeometry(0.3, 1.5, 8), bodyMat);
            tail.position.set(0, 4.5, -2.5);
            tail.rotation.x = Math.PI / 3;
            group.add(tail);

            return {
                group,
                legs,
                noseLight,
                isLeader,
                state: STATE.WANDER,
                stateTimer: 0,
                direction: Math.random() * Math.PI * 2,
                walkPhase: Math.random() * Math.PI * 2,
                walkSpeed: 0.8 + Math.random() * 0.4,
                circleAngle: 0,
                greetTarget: null,
                id
            };
        }

        function createImageCharacter(imagePath, position, height) {
            const group = new THREE.Group();
            group.position.copy(position);

            const geom = new THREE.PlaneGeometry(1, 1);
            const mat = new THREE.MeshBasicMaterial({ transparent: true, depthWrite: false });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.position.y = height / 2;
            group.add(mesh);

            const loader = new THREE.TextureLoader();
            loader.load(
                imagePath,
                (texture) => {
                    texture.encoding = THREE.sRGBEncoding;
                    mat.map = texture;
                    mat.needsUpdate = true;
                    const img = texture.image;
                    const aspect = (img && img.width && img.height) ? (img.width / img.height) : 1;
                    mesh.scale.set(aspect * height, height, 1);
                },
                undefined,
                (err) => {
                    console.warn('Failed to load texture', imagePath, err);
                }
            );

            return { group, mesh, imagePath };
        }

        function placeIceSculpturesAroundCastle() {
            const iceMat = new THREE.MeshPhongMaterial({ color: 0xbfefff, transparent: true, opacity: 0.9, shininess: 80 });
            for (let i = 0; i < 6; i++) {
                const geom = new THREE.OctahedronGeometry(1 + Math.random() * 2);
                const mesh = new THREE.Mesh(geom, iceMat);
                const angle = Math.random() * Math.PI * 2;
                const r = 10 + Math.random() * 6;
                mesh.position.set(Math.cos(angle) * r, 1 + Math.random() * 0.8, Math.sin(angle) * r);
                mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                scene.add(mesh);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            if (animationEnabled) {
                if (castleGroup) {
                    castleGroup.rotation.y += 0.001;
                    castleGroup.position.y = Math.sin(time * 0.5) * 0.5;
                }

                if (auroraEnabled && auroraPlane) {
                    const vertices = auroraPlane.geometry.attributes.position.array;
                    for (let i = 0; i < vertices.length; i += 3) {
                        vertices[i + 2] = Math.sin(vertices[i] * 0.1 + time) * 3;
                    }
                    auroraPlane.geometry.attributes.position.needsUpdate = true;
                    auroraPlane.material.opacity = 0.2 + Math.sin(time * 0.5) * 0.1;
                }

                if (snowEnabled && snowParticles) {
                    const positions = snowParticles.geometry.attributes.position.array;
                    const velocities = snowParticles.geometry.velocities;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += velocities[i / 3].x;
                        positions[i + 1] += velocities[i / 3].y;
                        positions[i + 2] += velocities[i / 3].z;

                        if (positions[i + 1] < 0) {
                            let nx, ny, nz;
                            do {
                                nx = Math.random() * 200 - 100;
                                ny = 100;
                                nz = Math.random() * 200 - 100;
                            } while (Math.sqrt(nx * nx + nz * nz) < castleExclusionRadius);
                            positions[i] = nx;
                            positions[i + 1] = ny;
                            positions[i + 2] = nz;
                        }
                    }
                    snowParticles.geometry.attributes.position.needsUpdate = true;
                }

                if (lake) lake.material.opacity = 0.6 + Math.sin(time * 0.3) * 0.1;

                if (lightsEnabled && castleLight1) {
                    castleLight1.intensity = 1.5 + Math.sin(time * 2) * 0.3;
                    castleLight2.intensity = 1.2 + Math.cos(time * 1.5) * 0.3;
                }

                if (auroraLight) auroraLight.intensity = 0.5 + Math.sin(time * 0.8) * 0.2;

                updateLanterns();
                updateSnowmen();
                updateReindeersWithInteractions();
                updateImageCharacters();
            }

            renderer.render(scene, camera);
        }

        function updateLanterns() {
            lanterns.forEach(l => {
                const flick = l.baseIntensity + Math.sin(time * l.flickerSpeed + Math.random()) * 0.12;
                l.light.intensity = flick;
                l.group.position.y = Math.sin(time * 0.5 + l.flickerSpeed) * 0.03;
            });
        }

        function updateSnowmen() {
            snowmen.forEach(s => {
                s.group.position.y = s.baseY + Math.sin(time * s.bobSpeed + s.bobOffset) * 0.08;
            });
        }

        function updateReindeersWithInteractions() {
            if (!anna) return;

            const annaPos = anna.group.position;
            const leader = reindeers.find(r => r.isLeader);

            reindeers.forEach(r => {
                const pos = r.group.position;
                r.stateTimer++;

                if (!interactionsEnabled) {
                    // Simple wandering without AI
                    r.walkPhase += 0.02;
                    const newX = pos.x + Math.cos(r.direction) * 0.08;
                    const newZ = pos.z + Math.sin(r.direction) * 0.08;
                    
                    // Check tree collision
                    let collision = false;
                    if (window.treePositions) {
                        for (let tree of window.treePositions) {
                            const dist = Math.sqrt((newX - tree.x) ** 2 + (newZ - tree.z) ** 2);
                            if (dist < tree.radius + 2) {
                                collision = true;
                                r.direction += Math.PI / 4;
                                break;
                            }
                        }
                    }
                    
                    if (!collision) {
                        pos.x = newX;
                        pos.z = newZ;
                    }
                    
                    if (Math.random() < 0.02) r.direction += (Math.random() - 0.5) * 0.5;
                    r.group.rotation.y = r.direction;
                    animateWalk(r);
                    keepInBounds(r);
                    return;
                }

                // Calculate distance to Anna
                const distToAnna = Math.sqrt(
                    (pos.x - annaPos.x) ** 2 + (pos.z - annaPos.z) ** 2
                );

                // STATE MACHINE LOGIC
                if (r.state === STATE.WANDER) {
                    // Random walking with smooth turns (no instant 180 degree turns)
                    if (Math.random() < 0.02) {
                        r.direction += (Math.random() - 0.5) * 0.3; // Smaller turn angles
                    }

                    // Check if Anna is nearby
                    if (distToAnna < 35) {
                        r.state = STATE.APPROACH;
                        r.stateTimer = 0;
                    }
                    // Leader rests sometimes
                    else if (r.isLeader && Math.random() < 0.005) {
                        r.state = STATE.REST;
                        r.stateTimer = 0;
                    }
                    // Follow leader
                    else if (!r.isLeader && leader && Math.random() < 0.01) {
                        const dL = Math.sqrt(
                            (pos.x - leader.group.position.x) ** 2 +
                            (pos.z - leader.group.position.z) ** 2
                        );
                        if (dL < 25) {
                            r.state = STATE.FOLLOW;
                            r.stateTimer = 0;
                        }
                    }

                    move(r, 0.08);
                }
                else if (r.state === STATE.APPROACH) {
                    // Move toward Anna with realistic turning
                    const dx = annaPos.x - pos.x;
                    const dz = annaPos.z - pos.z;
                    const targetDir = Math.atan2(dz, dx);
                    
                    // Smooth turning - don't snap instantly
                    let angleDiff = targetDir - r.direction;
                    // Normalize angle difference to -PI to PI
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    // Turn gradually towards target
                    r.direction += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 0.08);

                    // Stop at safe distance (8 units) before starting to circle
                    if (distToAnna < 8) {
                        r.state = STATE.CIRCLE;
                        r.circleAngle = Math.atan2(pos.z - annaPos.z, pos.x - annaPos.x);
                        r.stateTimer = 0;
                    } else {
                        move(r, 0.15);
                    }

                    // Timeout
                    if (r.stateTimer > 300) {
                        r.state = STATE.WANDER;
                        r.stateTimer = 0;
                    }
                }
                else if (r.state === STATE.CIRCLE) {
                    // Circle around Anna at safe distance
                    r.circleAngle += 0.015;
                    const radius = 10; // Keep 10 unit distance from Anna
                    const targetX = annaPos.x + Math.cos(r.circleAngle) * radius;
                    const targetZ = annaPos.z + Math.sin(r.circleAngle) * radius;

                    r.direction = Math.atan2(targetZ - pos.z, targetX - pos.x);
                    
                    // Check current distance to Anna - maintain safe distance
                    const currentDistToAnna = Math.sqrt((pos.x - annaPos.x) ** 2 + (pos.z - annaPos.z) ** 2);
                    
                    // Only move if we're at safe distance
                    if (currentDistToAnna > 8) {
                        // Move closer
                        const newX = pos.x + Math.cos(r.direction) * 0.1;
                        const newZ = pos.z + Math.sin(r.direction) * 0.1;
                        
                        // Check for tree collision while circling
                        let collision = false;
                        if (window.treePositions) {
                            for (let tree of window.treePositions) {
                                const dist = Math.sqrt((newX - tree.x) ** 2 + (newZ - tree.z) ** 2);
                                if (dist < tree.radius + 2) {
                                    collision = true;
                                    r.circleAngle += 0.1;
                                    break;
                                }
                            }
                        }
                        
                        if (!collision) {
                            pos.x = newX;
                            pos.z = newZ;
                        }
                    } else {
                        // Just rotate around, don't move closer
                        const tangentDir = r.circleAngle + Math.PI / 2;
                        pos.x += Math.cos(tangentDir) * 0.08;
                        pos.z += Math.sin(tangentDir) * 0.08;
                    }

                    // Brighter nose when circling
                    r.noseLight.intensity = 2 + Math.sin(time * 10) * 0.5;

                    // Stop circling eventually
                    if (r.stateTimer > 400 || Math.random() < 0.003) {
                        r.state = STATE.WANDER;
                        // Turn away smoothly instead of instant 180
                        r.direction += Math.PI / 4;
                        r.stateTimer = 0;
                    }
                }
                else if (r.state === STATE.FOLLOW) {
                    if (leader) {
                        const dx = leader.group.position.x - pos.x;
                        const dz = leader.group.position.z - pos.z;
                        const dist = Math.sqrt(dx * dx + dz * dz);

                        const targetDir = Math.atan2(dz, dx);
                        
                        // Smooth turning
                        let angleDiff = targetDir - r.direction;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        r.direction += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 0.08);

                        if (dist > 8) {
                            move(r, 0.12);
                        } else if (dist < 5) {
                            // Turn around smoothly instead of backing up
                            r.direction += 0.1;
                        }

                        // Join leader if approaching Anna
                        if (leader.state === STATE.APPROACH || leader.state === STATE.CIRCLE) {
                            if (distToAnna < 35) {
                                r.state = STATE.APPROACH;
                                r.stateTimer = 0;
                            }
                        }
                    }

                    if (r.stateTimer > 250) {
                        r.state = STATE.WANDER;
                        r.stateTimer = 0;
                    }
                }
                else if (r.state === STATE.REST) {
                    // Resting
                    r.noseLight.intensity = 0.5 + Math.sin(time * 3) * 0.2;
                    pos.y = Math.max(0, pos.y - 0.02);

                    // Wake up if Anna comes close
                    if (distToAnna < 30 && Math.random() < 0.05) {
                        r.state = STATE.APPROACH;
                        r.stateTimer = 0;
                        pos.y = 0;
                    }

                    if (r.stateTimer > 200) {
                        r.state = STATE.WANDER;
                        r.stateTimer = 0;
                        pos.y = 0;
                    }
                }

                // Face direction
                r.group.rotation.y = r.direction;

                // Animate
                animateWalk(r);

                // Collision avoidance
                reindeers.forEach(other => {
                    if (other !== r) {
                        const dx = pos.x - other.group.position.x;
                        const dz = pos.z - other.group.position.z;
                        const d = Math.sqrt(dx * dx + dz * dz);
                        if (d < 4) {
                            pos.x += (dx / d) * 0.1;
                            pos.z += (dz / d) * 0.1;
                        }
                    }
                });

                keepInBounds(r);
            });

            updateDebug();
        }

        function move(r, speed) {
            r.walkPhase += Math.abs(speed) * 0.4;
            
            // Always move forward in the direction the reindeer is facing
            const newX = r.group.position.x + Math.cos(r.direction) * Math.abs(speed);
            const newZ = r.group.position.z + Math.sin(r.direction) * Math.abs(speed);
            
            // Check collision with Anna (treat her as obstacle) - only if anna exists
            if (anna && anna.group) {
                const distToAnna = Math.sqrt((newX - anna.group.position.x) ** 2 + (newZ - anna.group.position.z) ** 2);
                if (distToAnna < 3) { // Don't walk through Anna (3 unit radius)
                    // Turn away from Anna
                    const angleAwayFromAnna = Math.atan2(newZ - anna.group.position.z, newX - anna.group.position.x);
                    r.direction = angleAwayFromAnna;
                    return; // Don't move this frame
                }
            }
            
            // Check collision with trees
            let collision = false;
            if (window.treePositions) {
                for (let tree of window.treePositions) {
                    const dist = Math.sqrt((newX - tree.x) ** 2 + (newZ - tree.z) ** 2);
                    if (dist < tree.radius + 2) { // 2 = reindeer radius
                        collision = true;
                        // Turn to avoid tree instead of stopping
                        const angleToTree = Math.atan2(tree.z - r.group.position.z, tree.x - r.group.position.x);
                        // Turn perpendicular to tree direction
                        r.direction = angleToTree + Math.PI / 2;
                        break;
                    }
                }
            }
            
            // Only move if no collision
            if (!collision) {
                r.group.position.x = newX;
                r.group.position.z = newZ;
            }
        }

        function animateWalk(r) {
            const bob = Math.abs(Math.sin(r.walkPhase)) * 0.2;
            r.group.position.y = bob;

            r.legs.forEach((leg, i) => {
                leg.rotation.x = Math.sin(r.walkPhase + i * Math.PI) * 0.3;
            });

            if (r.state !== STATE.CIRCLE && r.state !== STATE.REST) {
                r.noseLight.intensity = 1.5 + Math.sin(time * 8) * 0.3;
            }
        }

        function keepInBounds(r) {
            const pos = r.group.position;
            if (pos.x > 80) pos.x = 80;
            if (pos.x < -80) pos.x = -80;
            if (pos.z > 80) pos.z = 80;
            if (pos.z < -80) pos.z = -80;
        }

        function updateImageCharacters() {
            characters.forEach(c => {
                if (c.mesh) {
                    c.mesh.lookAt(camera.position);
                }
            });
        }

        function updateDebug() {
            if (!anna) return;
            let status = '';
            reindeers.forEach((r, i) => {
                const pos = r.group.position;
                const dist = Math.sqrt(
                    (pos.x - anna.group.position.x) ** 2 +
                    (pos.z - anna.group.position.z) ** 2
                );
                status += `R${i}${r.isLeader ? '(L)' : ''}: ${STATE_NAMES[r.state]} (${dist.toFixed(0)}m)<br>`;
            });
            document.getElementById('reindeer-status').innerHTML = status;
        }

        function setupEventListeners() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            window.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (e.code === 'Space' || key === ' ') {
                    animationEnabled = !animationEnabled;
                    e.preventDefault();
                    return;
                }
                switch (key) {
                    case 'a':
                        auroraEnabled = !auroraEnabled;
                        if (auroraPlane) auroraPlane.visible = auroraEnabled;
                        break;
                    case 's':
                        snowEnabled = !snowEnabled;
                        if (snowParticles) snowParticles.visible = snowEnabled;
                        break;
                    case 'l':
                        lightsEnabled = !lightsEnabled;
                        if (castleLight1) castleLight1.visible = lightsEnabled;
                        if (castleLight2) castleLight2.visible = lightsEnabled;
                        lanterns.forEach(l => l.group.visible = lightsEnabled);
                        break;
                    case 'i':
                        interactionsEnabled = !interactionsEnabled;
                        document.getElementById('int-status').textContent = interactionsEnabled ? 'ON' : 'OFF';
                        document.getElementById('int-status').className = interactionsEnabled ? 'on' : 'off';
                        
                        if (!interactionsEnabled) {
                            reindeers.forEach(r => {
                                r.state = STATE.WANDER;
                                r.stateTimer = 0;
                                r.greetTarget = null;
                            });
                        }
                        break;
                    case 'r':
                        const visibleR = !reindeers[0]?.group.visible;
                        reindeers.forEach(r => r.group.visible = visibleR);
                        break;
                    case 'm':
                        const visibleM = !snowmen[0]?.group.visible;
                        snowmen.forEach(s => s.group.visible = visibleM);
                        break;
                    case 'd':
                        actorsEnabled = !actorsEnabled;
                        if (actorsGroup) actorsGroup.visible = actorsEnabled;
                        break;
                }
            });
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>