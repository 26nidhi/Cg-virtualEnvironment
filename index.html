<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frozen 3D Environment - Computer Graphics Project</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #1a2a4e, #2d4a7c);
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 20, 60, 0.85);
            color: #a8d8ff;
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(168, 216, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        #info-panel h2 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(168, 216, 255, 0.5);
        }
        #info-panel p {
            margin: 8px 0;
            line-height: 1.6;
        }
        .control-key {
            background: rgba(168, 216, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            color: #ffffff;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 24px;
            text-align: center;
            text-shadow: 0 0 20px rgba(168, 216, 255, 0.8);
        }
        .spinner {
            border: 4px solid rgba(168, 216, 255, 0.3);
            border-top: 4px solid #a8d8ff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="loading">
        <div class="spinner"></div>
        <p>Loading Arendelle...</p>
    </div>
    
    <div id="info-panel">
        <h2>❄️ Frozen 3D Environment</h2>
        <p><span class="control-key">Mouse</span> - Rotate & Zoom</p>
        <p><span class="control-key">Space</span> - Toggle Animation</p>
        <p><span class="control-key">A</span> - Toggle Aurora</p>
        <p><span class="control-key">S</span> - Toggle Snow</p>
        <p><span class="control-key">L</span> - Toggle Lights</p>
        <p style="margin-top: 15px; font-size: 12px; color: #8ab8e6;">
            Computer Graphics Project<br>
            Three.js WebGL Rendering
        </p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // GLOBAL VARIABLES AND SCENE SETUP
        // ============================================
        let scene, camera, renderer, controls;
        let castleGroup, snowParticles, auroraPlane, lake;
        let animationEnabled = true;
        let auroraEnabled = true;
        let snowEnabled = true;
        let lightsEnabled = true;
        let time = 0;

        // Lighting references
        let ambientLight, directionalLight, castleLight1, castleLight2, auroraLight;

        // ============================================
        // INITIALIZATION FUNCTION
        // ============================================
        function init() {
            // Create scene with fog for depth perception
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a2a4e, 50, 300);

            // Setup camera with perspective projection
            // FOV: 60 degrees, Aspect ratio: window, Near: 0.1, Far: 1000
            camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(50, 30, 50);

            // WebGL Renderer setup with antialiasing
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Orbit Controls for interactive camera manipulation
            setupControls();

            // Create scene components
            createLighting();
            createTerrain();
            createCastle();
            createTrees();
            createLake();
            createAurora();
            createSnowParticles();

            // Event listeners
            setupEventListeners();

            // Hide loading screen
            document.getElementById('loading').style.display = 'none';

            // Start animation loop
            animate();
        }

        // ============================================
        // ORBIT CONTROLS SETUP
        // ============================================
        function setupControls() {
            // Manual OrbitControls implementation (simplified)
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let cameraRotation = { theta: 0, phi: Math.PI / 6 };
            let cameraDistance = 80;

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    cameraRotation.theta -= deltaX * 0.01;
                    cameraRotation.phi -= deltaY * 0.01;
                    cameraRotation.phi = Math.max(0.1, Math.min(Math.PI / 2, cameraRotation.phi));

                    updateCameraPosition();
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.05;
                cameraDistance = Math.max(30, Math.min(150, cameraDistance));
                updateCameraPosition();
            });

            function updateCameraPosition() {
                camera.position.x = cameraDistance * Math.sin(cameraRotation.phi) * Math.cos(cameraRotation.theta);
                camera.position.y = cameraDistance * Math.cos(cameraRotation.phi);
                camera.position.z = cameraDistance * Math.sin(cameraRotation.phi) * Math.sin(cameraRotation.theta);
                camera.lookAt(0, 15, 0);
            }

            updateCameraPosition();
        }

        // ============================================
        // LIGHTING SETUP - Ambient, Directional, Point Lights
        // ============================================
        function createLighting() {
            // Ambient light for overall scene illumination
            ambientLight = new THREE.AmbientLight(0x6699cc, 0.4);
            scene.add(ambientLight);

            // Directional light simulating sunlight/moonlight
            directionalLight = new THREE.DirectionalLight(0xaaccff, 0.8);
            directionalLight.position.set(50, 80, 30);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // Point lights inside castle for glow effect
            castleLight1 = new THREE.PointLight(0x88ccff, 1.5, 50);
            castleLight1.position.set(0, 25, 0);
            scene.add(castleLight1);

            castleLight2 = new THREE.PointLight(0xaaddff, 1.2, 40);
            castleLight2.position.set(0, 35, 0);
            scene.add(castleLight2);

            // Aurora-colored light
            auroraLight = new THREE.PointLight(0x00ff88, 0.5, 100);
            auroraLight.position.set(0, 60, -30);
            scene.add(auroraLight);
        }

        // ============================================
        // TERRAIN CREATION - Snow-covered ground
        // ============================================
        function createTerrain() {
            // Create ground plane with snow material
            const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            
            // Add some height variation for terrain
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.random() * 3 - 1; // Random height
            }
            groundGeometry.attributes.position.needsUpdate = true;
            groundGeometry.computeVertexNormals();

            // Snow material with Phong shading
            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                shininess: 60,
                specular: 0x444444,
                flatShading: false
            });

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            // Add some rocky outcrops
            for (let i = 0; i < 15; i++) {
                const rockGeometry = new THREE.SphereGeometry(
                    Math.random() * 3 + 1,
                    8,
                    8
                );
                const rockMaterial = new THREE.MeshPhongMaterial({
                    color: 0xaabbcc,
                    shininess: 10
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    Math.random() * 100 - 50,
                    -1,
                    Math.random() * 100 - 50
                );
                rock.scale.y = 0.5;
                rock.receiveShadow = true;
                rock.castShadow = true;
                scene.add(rock);
            }
        }

        // ============================================
        // ICE CASTLE CREATION - Polygonal modeling
        // ============================================
        function createCastle() {
            castleGroup = new THREE.Group();

            // Ice material with high reflectivity (Phong shading)
            const iceMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaddff,
                transparent: true,
                opacity: 0.85,
                shininess: 100,
                specular: 0xffffff,
                reflectivity: 0.9
            });

            // Main castle base
            const baseGeometry = new THREE.BoxGeometry(20, 20, 20);
            const base = new THREE.Mesh(baseGeometry, iceMaterial);
            base.position.y = 10;
            base.castShadow = true;
            base.receiveShadow = true;
            castleGroup.add(base);

            // Castle towers (4 corner towers)
            const towerPositions = [
                [-8, 0, -8], [8, 0, -8], [-8, 0, 8], [8, 0, 8]
            ];
            
            towerPositions.forEach(pos => {
                // Tower cylinder
                const towerGeometry = new THREE.CylinderGeometry(3, 4, 30, 8);
                const tower = new THREE.Mesh(towerGeometry, iceMaterial);
                tower.position.set(pos[0], pos[1] + 25, pos[2]);
                tower.castShadow = true;
                tower.receiveShadow = true;
                castleGroup.add(tower);

                // Tower cone roof
                const roofGeometry = new THREE.ConeGeometry(4.5, 8, 8);
                const roof = new THREE.Mesh(roofGeometry, iceMaterial);
                roof.position.set(pos[0], pos[1] + 44, pos[2]);
                roof.castShadow = true;
                castleGroup.add(roof);

                // Glowing window
                const windowGeometry = new THREE.SphereGeometry(0.8, 8, 8);
                const windowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffeeaa,
                    transparent: true,
                    opacity: 0.9
                });
                const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
                window1.position.set(pos[0], pos[1] + 30, pos[2] > 0 ? pos[2] + 4 : pos[2] - 4);
                castleGroup.add(window1);
            });

            // Central spire
            const spireGeometry = new THREE.ConeGeometry(5, 40, 6);
            const spire = new THREE.Mesh(spireGeometry, iceMaterial);
            spire.position.y = 45;
            spire.castShadow = true;
            castleGroup.add(spire);

            // Decorative ice crystals on top
            for (let i = 0; i < 5; i++) {
                const crystalGeometry = new THREE.OctahedronGeometry(2);
                const crystal = new THREE.Mesh(crystalGeometry, iceMaterial);
                const angle = (i / 5) * Math.PI * 2;
                crystal.position.set(
                    Math.cos(angle) * 8,
                    22,
                    Math.sin(angle) * 8
                );
                crystal.rotation.z = Math.random() * Math.PI;
                castleGroup.add(crystal);
            }

            scene.add(castleGroup);
        }

        // ============================================
        // PINE TREES - Snow-covered forest
        // ============================================
        function createTrees() {
            const treeMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a4d2e,
                shininess: 5
            });
            const snowMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                shininess: 30
            });

            for (let i = 0; i < 30; i++) {
                const treeGroup = new THREE.Group();

                // Tree trunk
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 5, 8);
                const trunk = new THREE.Mesh(trunkGeometry, treeMaterial);
                trunk.position.y = 2.5;
                trunk.castShadow = true;
                treeGroup.add(trunk);

                // Tree foliage (3 cone layers)
                for (let j = 0; j < 3; j++) {
                    const coneGeometry = new THREE.ConeGeometry(3 - j * 0.5, 5, 8);
                    const cone = new THREE.Mesh(coneGeometry, treeMaterial);
                    cone.position.y = 5 + j * 3;
                    cone.castShadow = true;
                    treeGroup.add(cone);

                    // Snow on top of each layer
                    const snowCone = new THREE.Mesh(
                        new THREE.ConeGeometry(3.2 - j * 0.5, 1, 8),
                        snowMaterial
                    );
                    snowCone.position.y = 7.5 + j * 3;
                    treeGroup.add(snowCone);
                }

                // Random positioning around the scene (avoid center)
                let x, z;
                do {
                    x = Math.random() * 120 - 60;
                    z = Math.random() * 120 - 60;
                } while (Math.abs(x) < 25 && Math.abs(z) < 25);

                treeGroup.position.set(x, 0, z);
                treeGroup.scale.setScalar(0.8 + Math.random() * 0.4);
                scene.add(treeGroup);
            }
        }

        // ============================================
        // FROZEN LAKE - Reflective surface
        // ============================================
        function createLake() {
            const lakeGeometry = new THREE.CircleGeometry(25, 32);
            const lakeMaterial = new THREE.MeshPhongMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.7,
                shininess: 150,
                specular: 0xffffff,
                side: THREE.DoubleSide
            });

            lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
            lake.rotation.x = -Math.PI / 2;
            lake.position.set(35, 0.1, 35);
            lake.receiveShadow = true;
            scene.add(lake);

            // Add ice chunks
            for (let i = 0; i < 8; i++) {
                const iceGeometry = new THREE.DodecahedronGeometry(Math.random() * 2 + 1);
                const iceMaterial = new THREE.MeshPhongMaterial({
                    color: 0xcceeFF,
                    transparent: true,
                    opacity: 0.8,
                    shininess: 100
                });
                const iceChunk = new THREE.Mesh(iceGeometry, iceMaterial);
                const angle = (i / 8) * Math.PI * 2;
                const radius = 15 + Math.random() * 8;
                iceChunk.position.set(
                    35 + Math.cos(angle) * radius,
                    0.5,
                    35 + Math.sin(angle) * radius
                );
                iceChunk.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                scene.add(iceChunk);
            }
        }

        // ============================================
        // AURORA BOREALIS - Animated sky effect
        // ============================================
        function createAurora() {
            // Create aurora using a large textured plane
            const auroraGeometry = new THREE.PlaneGeometry(150, 80, 32, 32);
            
            // Modify geometry for wave effect
            const vertices = auroraGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.sin(vertices[i] * 0.1) * 3;
            }
            auroraGeometry.attributes.position.needsUpdate = true;

            // Aurora material with gradient colors
            const auroraMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });

            auroraPlane = new THREE.Mesh(auroraGeometry, auroraMaterial);
            auroraPlane.position.set(0, 60, -50);
            auroraPlane.rotation.x = Math.PI / 6;
            scene.add(auroraPlane);

            // Add second aurora layer
            const aurora2 = auroraPlane.clone();
            aurora2.material = auroraMaterial.clone();
            aurora2.material.color.setHex(0x4488ff);
            aurora2.position.z = -55;
            aurora2.position.y = 55;
            scene.add(aurora2);
        }

        // ============================================
        // SNOW PARTICLE SYSTEM
        // ============================================
        function createSnowParticles() {
            const particleCount = 5000;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            // Initialize particle positions and velocities
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = Math.random() * 200 - 100;
                positions[i * 3 + 1] = Math.random() * 100;
                positions[i * 3 + 2] = Math.random() * 200 - 100;

                velocities.push({
                    x: Math.random() * 0.1 - 0.05,
                    y: -Math.random() * 0.2 - 0.1,
                    z: Math.random() * 0.1 - 0.05
                });
            }

            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.velocities = velocities;

            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.5,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            snowParticles = new THREE.Points(particles, particleMaterial);
            scene.add(snowParticles);
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            if (animationEnabled) {
                // Animate castle - gentle floating motion
                if (castleGroup) {
                    castleGroup.rotation.y += 0.001;
                    castleGroup.position.y = Math.sin(time * 0.5) * 0.5;
                }

                // Animate aurora - wave motion
                if (auroraEnabled && auroraPlane) {
                    const vertices = auroraPlane.geometry.attributes.position.array;
                    for (let i = 0; i < vertices.length; i += 3) {
                        vertices[i + 2] = Math.sin(vertices[i] * 0.1 + time) * 3;
                    }
                    auroraPlane.geometry.attributes.position.needsUpdate = true;
                    auroraPlane.material.opacity = 0.2 + Math.sin(time * 0.5) * 0.1;
                }

                // Animate snow particles
                if (snowEnabled && snowParticles) {
                    const positions = snowParticles.geometry.attributes.position.array;
                    const velocities = snowParticles.geometry.velocities;

                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i] += velocities[i / 3].x;
                        positions[i + 1] += velocities[i / 3].y;
                        positions[i + 2] += velocities[i / 3].z;

                        // Reset particle when it falls below ground
                        if (positions[i + 1] < 0) {
                            positions[i + 1] = 100;
                            positions[i] = Math.random() * 200 - 100;
                            positions[i + 2] = Math.random() * 200 - 100;
                        }
                    }
                    snowParticles.geometry.attributes.position.needsUpdate = true;
                }

                // Animate lake reflection
                if (lake) {
                    lake.material.opacity = 0.6 + Math.sin(time * 0.3) * 0.1;
                }

                // Animate castle lights
                if (lightsEnabled && castleLight1) {
                    castleLight1.intensity = 1.5 + Math.sin(time * 2) * 0.3;
                    castleLight2.intensity = 1.2 + Math.cos(time * 1.5) * 0.3;
                }

                // Animate aurora light
                if (auroraLight) {
                    auroraLight.intensity = 0.5 + Math.sin(time * 0.8) * 0.2;
                }
            }

            renderer.render(scene, camera);
        }

        // ============================================
        // EVENT LISTENERS - Keyboard controls
        // ============================================
        function setupEventListeners() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            window.addEventListener('keydown', (e) => {
                switch(e.key.toLowerCase()) {
                    case ' ':
                        animationEnabled = !animationEnabled;
                        break;
                    case 'a':
                        auroraEnabled = !auroraEnabled;
                        if (auroraPlane) auroraPlane.visible = auroraEnabled;
                        break;
                    case 's':
                        snowEnabled = !snowEnabled;
                        if (snowParticles) snowParticles.visible = snowEnabled;
                        break;
                    case 'l':
                        lightsEnabled = !lightsEnabled;
                        if (castleLight1) castleLight1.visible = lightsEnabled;
                        if (castleLight2) castleLight2.visible = lightsEnabled;
                        break;
                }
            });
        }

        // ============================================
        // START THE APPLICATION
        // ============================================
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>